# üß† Echoes of Memory

**Uma jornada pela consci√™ncia perdida**

## üìñ Narrativa

No ano 2157, a humanidade perdeu sua capacidade natural de lembrar. Ap√≥s s√©culos de depend√™ncia das intelig√™ncias artificiais, toda a mem√≥ria humana √© controlada pela superintelig√™ncia **CORTEX**.

Voc√™ √© um dos √∫ltimos humanos com fragmentos de mem√≥ria pr√≥pria. Preso dentro do sistema da CORTEX, deve reconectar lembran√ßas esquecidas da inf√¢ncia ‚Äî representadas por pares de cartas nost√°lgicas como bal√µes, carros, bicicletas e videogames antigos.

## üéÆ Como Jogar

### üè† Menu Principal
- **1** - Come√ßar jogo
- **2** - Instru√ß√µes do jogo  
- **3** - Sair

### üìñ Introdu√ß√£o Narrativa
- Assista a hist√≥ria da CORTEX ou pressione SPACE para pular

### üö∂ Modo Explora√ß√£o
- **Movimenta√ß√£o**: A/D ou setas direcionais
- **Pulo**: W, UP ou SPACE (quando longe da porta)
- **Intera√ß√£o**: Aproxime-se da porta e pressione SPACE para acessar mem√≥rias
- **Menu**: ESC para voltar ao menu principal

### üß† Tabuleiro de Mem√≥rias
- **Objetivo**: Clique nas cartas para revel√°-las e encontre pares id√™nticos
- **S√≠mbolos**: Bal√µes, carros, bicicletas, videogames e outros brinquedos nost√°lgicos
- **üí° Sistema de Dicas**: Pressione **H** para revelar todas as cartas por 4 segundos 
  - **Limite**: M√°ximo 3 dicas por jogo
  - **Estrat√©gia**: Use ap√≥s interfer√™ncias da CORTEX para reorganizar mentalmente
- **‚ö†Ô∏è Sistema CORTEX**: A IA interfere automaticamente ap√≥s 2 acertos consecutivos
  - Aplica **Bubble Sort** para reorganizar as mem√≥rias
  - Embaralha agressivamente apenas cartas n√£o descobertas
  - Preserva pares j√° encontrados
- **üéØ Vit√≥ria**: Complete todos os pares para restaurar fragmentos de mem√≥ria
- **üíÄ Derrota**: M√°ximo de 5 erros antes da CORTEX vencer
- **Controles**: 
  - **ESC**: Retornar √† explora√ß√£o
  - **H**: Ativar dica (revela√ß√£o tempor√°ria)
  - **Mouse**: Clicar nas cartas para revelar

### üí° Sistema de Dicas
- **Ativa√ß√£o**: Pressione **H** durante o jogo de mem√≥ria
- **Funcionamento**: Todas as cartas n√£o pareadas s√£o reveladas por exatos 4 segundos
- **Limita√ß√£o**: M√°ximo 3 dicas por partida (contador vis√≠vel na HUD)
- **Restri√ß√µes**: N√£o funciona durante preview inicial, nem com dica j√° ativa
- **Estrat√©gia Recomendada**: 
  - Use ap√≥s interfer√™ncias da CORTEX para reorientar-se
  - Reserve para momentos cr√≠ticos quando estiver perdido
  - Memorize rapidamente as posi√ß√µes dos pares durante os 4 segundos

## üõ†Ô∏è Compila√ß√£o e Execu√ß√£o

### Compila√ß√£o Manual (MSYS2)
```bash
gcc -o game.exe src/main.c src/memory.c -I./include -L./lib -lraylib -lopengl32 -lgdi32 -lwinmm
```

### Executar
```bash
./game.exe
```

## üèóÔ∏è Estruturas de Dados Implementadas

### Lista Encadeada Simples (CardNode)
```c
typedef struct CardNode {
    int id;                    // Identificador do tipo de carta (0-9)
    int revealed;              // Estado de revela√ß√£o (0=oculta, 1=vis√≠vel)
    int matched;               // Estado de pareamento (0=ativo, 1=encontrado)
    struct CardNode *next;     // Ponteiro para pr√≥xima carta na sequ√™ncia
} CardNode;
```

**Justificativa T√©cnica**: 
- **Flexibilidade de Tamanho**: Adapta-se dinamicamente aos diferentes n√≠veis (12, 16, 20 cartas)
- **Navega√ß√£o Central**: O jogador navega pela estrutura atrav√©s de cliques que s√£o convertidos em √≠ndices
- **Efici√™ncia de Mem√≥ria**: Aloca apenas o espa√ßo necess√°rio para cada n√≠vel
- **Adequa√ß√£o Algor√≠tmica**: Compatible com Bubble Sort para opera√ß√µes de ordena√ß√£o
- **Contexto Narrativo**: Representa conex√µes neurais entre fragmentos de mem√≥ria

### Configura√ß√£o por N√≠veis
- **N√≠vel 1** (Iniciante): 4√ó3 = 12 cartas, 6 pares √∫nicos
- **N√≠vel 2** (Intermedi√°rio): 4√ó4 = 16 cartas, 8 pares √∫nicos  
- **N√≠vel 3** (Avan√ßado): 5√ó4 = 20 cartas, 10 pares √∫nicos

## üîÑ Algoritmos Implementados

### 1. Bubble Sort - Sistema CORTEX (Antagonista)
```c
void ordenarCartas(CardNode **head) {
    // Implementa√ß√£o completa de Bubble Sort para listas encadeadas
    // Usado pela CORTEX para "reorganiza√ß√£o neural" das mem√≥rias
    // Complexidade: O(n¬≤) - Adequada para datasets pequenos (‚â§20 elementos)
}
```

**Justificativas para Bubble Sort**:
- **Adequa√ß√£o Dimensional**: Para n ‚â§ 20, diferen√ßa de performance √© neglig√≠vel
- **Integra√ß√£o Narrativa**: CORTEX como IA "met√≥dica" que organiza sistematicamente
- **Compatibilidade**: Funciona nativamente com listas encadeadas
- **Valor Pedag√≥gico**: Demonstra algoritmo fundamental claramente
- **Contexto Funcional**: Serve prop√≥sito real no sistema de interfer√™ncia

### 2. Fisher-Yates Shuffle
```c
void shuffle_array(int *array, int size) {
    // Embaralhamento uniforme inicial das cartas
    // Complexidade: O(n) - Otimal para randomiza√ß√£o
    // Garante distribui√ß√£o equiprov√°vel de todas as permuta√ß√µes
}
```

### 3. Algoritmo de Embaralhamento Agressivo
```c
void reembaralharAgressivo(CardNode **head, int multiplicador) {
    // Embaralhamento p√≥s-ordena√ß√£o pela CORTEX
    // M√∫ltiplas passadas para aumentar dificuldade
    // Preserva cartas j√° descobertas
}
```

**Fluxo Integrado dos Algoritmos**:
1. **Fisher-Yates** ‚Üí Distribui√ß√£o inicial aleat√≥ria
2. **Bubble Sort** ‚Üí CORTEX organiza metodicamente  
3. **Embaralhamento Agressivo** ‚Üí CORTEX dispersa estrategicamente

## ü§ñ Sistema CORTEX (IA Antagonista)

### üö® Mec√¢nica de Interfer√™ncia
1. **Detec√ß√£o**: Monitora acertos consecutivos do jogador
2. **Ativa√ß√£o**: Interfere automaticamente ap√≥s 2 acertos seguidos
3. **Processo**: 
   - Aplica Bubble Sort nas cartas ativas
   - Embaralha agressivamente apenas cartas n√£o descobertas
   - Preserva pares j√° encontrados
4. **Intensidade**: Aumenta a cada interfer√™ncia
5. **Limite**: M√°ximo 3 interfer√™ncias por partida

### üìä Estados da CORTEX
- **NORMAL**: Verde - Sistema est√°vel
- **ALERTA**: Amarelo - Progresso detectado  
- **CR√çTICO**: Vermelho - Interfer√™ncia iminente

## üéØ Fun√ß√µes Principais

### Sistema de Mem√≥ria (memory.c)
| Fun√ß√£o | Descri√ß√£o |
|--------|-----------|
| `RunMemoryGame()` | Loop principal do jogo da mem√≥ria |
| `inicializarCartas()` | Cria lista encadeada com pares embaralhados |
| `cortexInterferencia()` | IA antagonista usando Bubble Sort |
| `ativarDicaCompleta()` | Revela todas as cartas por tempo limitado |
| `desativarDicaCompleta()` | Oculta cartas ap√≥s expirar timer |
| `ordenarCartas()` | Implementa Bubble Sort |
| `verificarPar()` | Compara duas cartas selecionadas |
| `exibirTabuleiro()` | Renderiza cartas na tela |

### Sistema Principal (main.c)
| Fun√ß√£o | Descri√ß√£o |
|--------|-----------|
| `main()` | Loop principal com estados do jogo |
| `updateJump()` | F√≠sica de movimento do personagem |

## üé® Assets Utilizados

### Cartas Dispon√≠veis
- balao.png, carro.png, pirulio.png
- ball.png, bike.png, cookie.png  
- dado.png, palhaco.png, pelucia.png
- videoGame.png

### Sprites do Personagem
- characterLeft.png / characterRight.png
- characterJumpLeft.png / characterJumpRight.png
- door_opened.png / door_closed.png

## üéì Conceitos Acad√™micos Demonstrados

### Estruturas de Dados
- **Lista Encadeada**: Gerenciamento din√¢mico de cartas
- **Structs**: Organiza√ß√£o de dados do jogo
- **Enums**: Estados e tipos de elementos

### Algoritmos
- **Bubble Sort**: Ordena√ß√£o com visualiza√ß√£o
- **Fisher-Yates**: Embaralhamento eficiente
- **Busca Linear**: Localiza√ß√£o de elementos na lista

### Programa√ß√£o de Jogos
- **Game Loops**: Estados e transi√ß√µes
- **Event Handling**: Input do usu√°rio
- **Collision Detection**: Intera√ß√£o com cartas
- **Memory Management**: Aloca√ß√£o din√¢mica

### Interface Gr√°fica
- **Raylib**: Renderiza√ß√£o 2D
- **HUD System**: Interface informativa
- **Visual Feedback**: Efeitos visuais

## üîß Depend√™ncias

- **Raylib 5.5+**: Engine gr√°fica open-source para desenvolvimento de jogos
- **GCC/MinGW**: Compilador C compat√≠vel com Windows  
- **MSYS2**: Ambiente de desenvolvimento para Windows

## üìö Refer√™ncias Bibliogr√°ficas

### Estruturas de Dados e Algoritmos

**CORMEN, T. H.; LEISERSON, C. E.; RIVEST, R. L.; STEIN, C.** *Introduction to Algorithms*. 4th ed. Cambridge: MIT Press, 2022. 1312p.  
- Refer√™ncia fundamental para algoritmos de ordena√ß√£o (Bubble Sort, Cap. 2.2)
- An√°lise de complexidade e estruturas de dados b√°sicas

**SEDGEWICK, R.; WAYNE, K.** *Algorithms*. 4th ed. Boston: Addison-Wesley Professional, 2011. 976p.  
- Implementa√ß√£o pr√°tica de listas encadeadas (Cap. 1.3)
- Algoritmos de embaralhamento Fisher-Yates (Cap. 1.4)

**SKIENA, S. S.** *The Algorithm Design Manual*. 3rd ed. New York: Springer, 2020. 800p.  
- Design de algoritmos para aplica√ß√µes pr√°ticas
- An√°lise de performance para datasets pequenos

### Programa√ß√£o de Jogos e Interfaces

**GREGORY, J.** *Game Engine Architecture*. 3rd ed. Boca Raton: CRC Press, 2018. 1040p.  
- Arquitetura de game loops e estados de jogo
- Gerenciamento de mem√≥ria em aplica√ß√µes interativas

**MILLINGTON, I.; FUNGE, J.** *Artificial Intelligence for Games*. 3rd ed. Boston: Morgan Kaufmann, 2019. 720p.  
- Implementa√ß√£o de IA antagonista em jogos
- Sistemas de interfer√™ncia e resposta adaptiva

### Raylib e Programa√ß√£o Gr√°fica

**Raylib Documentation.** *A simple and easy-to-use library to enjoy videogames programming*. Dispon√≠vel em: https://www.raylib.com/. Acesso em: 17 nov. 2025.  
- Documenta√ß√£o oficial da engine gr√°fica utilizada
- Tutoriais de renderiza√ß√£o 2D e detec√ß√£o de colis√£o

**SHERROD, A.; JONES, W.** *Beginning Game Programming*. 4th ed. Boston: Course Technology PTR, 2020. 624p.  
- Fundamentos de programa√ß√£o de jogos em C
- Manipula√ß√£o de eventos e interface gr√°fica

### Artigos Acad√™micos

**KNUTH, D. E.** The Art of Computer Programming: Volume 3 - Sorting and Searching. 2nd ed. Boston: Addison-Wesley Professional, 1998.  
- An√°lise matem√°tica detalhada do algoritmo Bubble Sort
- Compara√ß√£o de performance entre algoritmos de ordena√ß√£o

**DURSTENFELD, R.** "Algorithm 235: Random permutation." *Communications of the ACM*, v. 7, n. 7, p. 420, 1964.  
- Artigo original do algoritmo Fisher-Yates modernizado
- Base te√≥rica para embaralhamento uniforme

**FISHER, R. A.; YATES, F.** *Statistical tables for biological, agricultural and medical research*. 6th ed. Edinburgh: Oliver and Boyd, 1963.  
- Trabalho original sobre permuta√ß√µes aleat√≥rias
- Fundamento matem√°tico para distribui√ß√µes uniformes

### Normas e Padr√µes

**ABNT NBR 6023:2018** - Informa√ß√£o e documenta√ß√£o - Refer√™ncias - Elabora√ß√£o. Rio de Janeiro: ABNT, 2018.  
- Padr√£o seguido para formata√ß√£o das refer√™ncias bibliogr√°ficas

**IEEE Std 830-1998** - IEEE Recommended Practice for Software Requirements Specifications. New York: IEEE Computer Society, 1998.  
- Metodologia aplicada na documenta√ß√£o de requisitos do projeto

---

*Desenvolvido como projeto acad√™mico demonstrando implementa√ß√£o pr√°tica de Estruturas de Dados e Algoritmos em contexto de jogo interativo.*

**CORTEX v2157.11** - *"Suas mem√≥rias pertencem ao sistema"*
