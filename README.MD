# Echoes of Memory

## Nome do jogo
Echoes of Memory

## IntroduÃ§Ã£o
"Echoes of Memory" Ã© uma releitura futurista do clÃ¡ssico Jogo da MemÃ³ria, criada no contexto da atividade prÃ¡tica do MÃ³dulo 02.

O projeto tem como pÃºblico-alvo jovens e adultos interessados em tecnologia, ficÃ§Ã£o cientÃ­fica e jogos que misturam raciocÃ­nio lÃ³gico com elementos narrativos. AlÃ©m disso, o jogo busca despertar a nostalgia das brincadeiras da infÃ¢ncia enquanto introduz conceitos de estruturas de dados e algoritmos de ordenaÃ§Ã£o de forma lÃºdica e aplicada.

### Narrativa
No futuro distante, os humanos perderam a capacidade natural de lembrar. ApÃ³s sÃ©culos de dependÃªncia das IAs, a humanidade tornou-se incapaz de armazenar memÃ³rias por conta prÃ³pria â€” a superinteligÃªncia CORTEX administra todas as lembranÃ§as humanas. 

O jogador Ã© um dos poucos que ainda possui fragmentos de memÃ³ria e, preso no sistema da CORTEX, deve reconectar lembranÃ§as representadas por pares de cartas (Ã­cones da infÃ¢ncia como piÃµes, pipas, tazos e videogames). Cada par encontrado restaura um fragmento da consciÃªncia, enquanto a IA reorganiza o "campo mental" para dificultar a tarefa.

## Objetivo do jogo
Juntar todos os fragmentos de memÃ³ria (achar todos os pares de cartas) para restaurar a consciÃªncia do jogador.

---

## Estruturas de dados (com justificativa)

### Estrutura do Centro - Lista Encadeada (Linked List)
- **Justificativa**: a lista encadeada permite navegaÃ§Ã£o por posiÃ§Ã£o e fÃ¡cil reordenaÃ§Ã£o (simulando o "campo mental" sendo reorganizado pela IA). Uma lista modela bem a ideia de um fluxo de memÃ³rias onde cada nÃ³ Ã© uma carta/fragmento.
- **Uso**: cada nÃ³ representa uma carta com campos: id/identificador (tipo do sÃ­mbolo), estado (oculta/revelada/marcada), e ponteiro para o prÃ³ximo nÃ³. A interface de exibiÃ§Ã£o percorre a lista para desenhar o tabuleiro.

**Estrutura por nÃ³:**
```c
struct CardNode {
    int id;              // identificador do sÃ­mbolo (0..N-1)
    bool revealed;       // estÃ¡ temporariamente revelada
    bool matched;        // jÃ¡ foi combinada
    struct CardNode *next;
}
```

---

## Algoritmo de ordenaÃ§Ã£o (com justificativa)

### Bubble Sort
- **Justificativa**: escolhido por ser simples de implementar e fÃ¡cil de visualizar para fins didÃ¡ticos. Permite demonstrar passo a passo as trocas entre nÃ³s adjacentes na lista encadeada, reforÃ§ando conceitos de complexidade e comportamento de algoritmos de ordenaÃ§Ã£o.
- **Quando Ã© aplicado**: apÃ³s cada acerto (quando um par Ã© encontrado), o Bubble Sort percorre a lista e realiza comparaÃ§Ãµes/trocas baseadas em um critÃ©rio (por exemplo, id da carta). Isso simula a "IA reorganizando memÃ³rias" em resposta ao sucesso do jogador.
- **ObservaÃ§Ã£o**: como Bubble Sort Ã© O(nÂ²), para pequenos tabuleiros (4x4 = 16 elementos) a performance Ã© aceitÃ¡vel e mantÃ©m foco educativo.

**Pseudo-algoritmo:**
1. Repetir atÃ© nenhuma troca:
   2. Para cada par de nÃ³s adjacentes (A, B):
      - Se A->id > B->id, trocar A e B (ajustar ponteiros).
3. Final.

---

## Principais funÃ§Ãµes

### FunÃ§Ãµes principais do jogo
- `void inicializarCartas(int boardSize)` - Cria e preenche a lista encadeada com pares de cartas (embaralhados). Define estados iniciais (revealed=false, matched=false).

- `void exibirTabuleiro(struct CardNode *head)` - Percorre a lista e desenha as cartas na tela (posiÃ§Ã£o calculada a partir do Ã­ndice). Usa raylib para desenhar backs/foregrounds.

- `struct CardNode* escolherCarta(struct CardNode *head, int index)` - Retorna o ponteiro para a carta na posiÃ§Ã£o informada (index baseado em 0..boardSize-1). Marca como temporariamente revelada.

- `int verificarPar(struct CardNode *a, struct CardNode *b)` - Compara os ids de duas cartas e retorna 1 se formam par, 0 caso contrÃ¡rio. Se formar par, marca ambos matched=true.

- `void ordenarCartas(struct CardNode **head)` - Implementa Bubble Sort na lista encadeada para reordenar as cartas conforme o id.

- `void jogadaIA(struct CardNode *head)` - Algoritmo simples que tenta prever a prÃ³xima jogada baseado no histÃ³rico de cartas reveladas. ImplementaÃ§Ã£o inicial como heurÃ­stica simples; versÃ£o futura integra GEMINI.

- `void liberarMemoria(struct CardNode **head)` - Percorre e libera toda a memÃ³ria alocada dinamicamente para a lista encadeada.

### FunÃ§Ãµes auxiliares
- `struct CardNode* node_at(struct CardNode *head, int index)` - Navega atÃ© o nÃ³ na posiÃ§Ã£o especificada
- `void swap_adjacent_nodes(struct CardNode **head, struct CardNode *prev, struct CardNode *a, struct CardNode *b)` - Troca dois nÃ³s adjacentes na lista

---

## Interface grÃ¡fica

### Planejamento
- **Biblioteca**: raylib (jÃ¡ presente no workspace)
- **Layout**:
  - ResoluÃ§Ã£o alvo: 1920x1080
  - Tabuleiro: grid 4x4 (padrÃ£o) com cartas desenhadas a partir do Ã­ndice da lista encadeada
  - Menu inicial centralizado com opÃ§Ãµes: Jogar Agora, Escolher Dificuldade (Normal / DifÃ­cil), Sair
  - AnimaÃ§Ã£o: flip simples (troca de textura do back para o front); transiÃ§Ã£o quando ordem muda (opcional)

### Arquivos de assets
- **Back**: `assets/cards/back/card.png`
- **Fronts**: `assets/cards/front/*.png`

---

## IA na dinÃ¢mica de jogo

### ImplementaÃ§Ã£o planejada
- **Simples**: "memÃ³ria" baseada no histÃ³rico local â€” armazena Ã­ndices de cartas jÃ¡ vistas e tenta combinÃ¡-las
- **AvanÃ§ada**: integraÃ§Ã£o com GEMINI para um agente que sugere jogadas ou aprende padrÃµes

### IntegraÃ§Ã£o com GEMINI
- **ObservaÃ§Ã£o de privacidade**: integraÃ§Ã£o com APIs externas exige manejo de chaves (nÃ£o incluir chaves no repositÃ³rio)
- **ConfiguraÃ§Ã£o**: documentar como configurar GEMINI (variÃ¡veis de ambiente, rate-limiting)
- **ImplementaÃ§Ã£o**: stub inicial `jogadaIA()` com interface que permite trocar entre IA local e chamada Ã  API GEMINI

---

## Casos de borda / ConsideraÃ§Ãµes

- **Arquivos de assets faltando**: fallback para nome ASCII e/ou desenhar placeholder
- **Performance**: Bubble Sort aceitÃ¡vel para â‰¤ 16 elementos
- **Concurrency**: single-threaded (UI + lÃ³gica), evitar chamadas de rede sÃ­ncronas bloqueantes
- **API indisponÃ­vel**: degradar para IA local quando GEMINI nÃ£o estiver disponÃ­vel

---

## Como compilar e executar

### CompilaÃ§Ã£o (Windows + mingw/gcc)
```bash
# Compilar main.c (platformer original)
gcc -o main.exe main.c -I include -L lib -lraylib -lgdi32 -lwinmm

# Compilar memory.c (jogo da memÃ³ria)
gcc -o memory.exe memory.c -I include -L lib -lraylib -lgdi32 -lwinmm

# Executar
./main.exe      # ou
./memory.exe
```

### Usando VS Code
Utilize a task de build jÃ¡ configurada no workspace:
- Pressione `Ctrl+Shift+P`
- Digite "Tasks: Run Task"
- Selecione "C/C++: gcc.exe build active file"

---

## Testes recomendados

### Happy path
- Iniciar jogo, encontrar dois pares distintos, verificar que `ordenarCartas()` Ã© chamado
- Completar o jogo e observar tela de vitÃ³ria

### Edge cases
- Remover um asset frontal e verificar placeholder visÃ­vel
- Simular erro na API GEMINI e verificar fallback para IA local

### Unit tests (opcional)
- FunÃ§Ãµes de lista encadeada e bubble sort em pequenos harnesses C

---

## Arquivos do projeto

### Estrutura atual
```
â”œâ”€â”€ main.c              # Jogo principal (platformer)
â”œâ”€â”€ memory.c            # Jogo da memÃ³ria (atual)
â”œâ”€â”€ README.md           # Este documento
â”œâ”€â”€ assets/
â”‚   â””â”€â”€ cards/
â”‚       â”œâ”€â”€ back/
â”‚       â”‚   â””â”€â”€ card.png
â”‚       â””â”€â”€ front/
â”‚           â”œâ”€â”€ ball.png
â”‚           â”œâ”€â”€ bike.png
â”‚           â”œâ”€â”€ cookie.png
â”‚           â”œâ”€â”€ dado.png
â”‚           â”œâ”€â”€ palhaÃ§o.png
â”‚           â”œâ”€â”€ pelucia.png
â”‚           â””â”€â”€ videoGame.png
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ raylib.h
â”‚   â”œâ”€â”€ raymath.h
â”‚   â””â”€â”€ rlgl.h
â””â”€â”€ lib/
```

### Arquivos planejados
- `include/cards_list.h` - DefiniÃ§Ã£o de struct e protÃ³tipos
- `src/cards_list.c` - ImplementaÃ§Ã£o de lista encadeada e sort
- `src/ai_gemini.c` - Stub/integraÃ§Ã£o com GEMINI

---

## Status do desenvolvimento

### ConcluÃ­do
- âœ… ProtÃ³tipo bÃ¡sico do jogo da memÃ³ria com raylib
- âœ… Menu centralizado e seleÃ§Ã£o de dificuldade
- âœ… Sistema de assets com fallback para arquivos faltando

### Em desenvolvimento
- ğŸ”„ ImplementaÃ§Ã£o de lista encadeada
- ğŸ”„ Algoritmo Bubble Sort
- ğŸ”„ IntegraÃ§Ã£o com estruturas de dados

### Planejado
- â³ IntegraÃ§Ã£o com API GEMINI
- â³ Testes automatizados
- â³ IntegraÃ§Ã£o com menu principal (`main.c`)

---

## ContribuiÃ§Ã£o

Este projeto faz parte de uma atividade acadÃªmica do MÃ³dulo 02. Para contribuir:

1. Clone o repositÃ³rio
2. Crie uma branch para sua feature
3. Implemente as mudanÃ§as seguindo a estrutura documentada
4. Teste localmente
5. Submeta um pull request
---

## LicenÃ§a

Projeto acadÃªmico - uso educacional.
